Das  Model  beheimatet   alle  Daten  sowie  ein   Grossteil  der  Algorithmen
(zus\"atzliche  Algorithmen sind  in  der Klasse  Calc  des Package  Utilities
zu  finden). Das  Model  ist  observable  um ein  update()  aus  der  View  zu
erm\"oglichen.

\subsubsection*{Model}
Die  Klasse  Model erzeugt  im  Konstruktor  f\"ur jede  Berechnungsart  einen
\code{ClosedLoop}. Sie enth\"alt Setter-  und Getter-Methoden zur Verarbeitung
der Daten in weiteren Klassen.

\subsubsection*{ClosedLoop}
In   der  Klasse   \code{ClosedLoop}   wird  \"uber   eine  Case-Abfrage   die
jeweilige Berechnungsart der passende \code{Controller} erstellt. Zus\"atzlich
beinhaltet  die Klasse  die  Methode  \code{calculate()}. Diese berechnet  zum
einen die Schrittantwort mittels  \code{calculateStepResponse()} und f\"ur die
optimiert f\"ur die  Phasengangmethode zus\"atzlich das \"Uberschwingverhalten
mittels der Methode \code{overShootOptimazation()}.


\subsubsection*{Controller}
Die Klasse \code{Controller} bildet die  Oberklasse aller Faustformeln und der
Phasengang-Methode. Sie  beinhaltet  die abstrakte  Klasse  \code{calculate()}
sowie alle n\"otigen Setter- und Getter-Methoden.

\subsubsection*{Faustformeln}

\code{Chien20},   \code{ChienApper},   \code{Oppelt},   \code{Rosenberg}   und
\code{ZieglerNichols} sind  die Klassen  zu den  zugeh\"origen Fausformeln. In
diesen  gibt   es  jeweils  eine   Methode  \code{calculate()},  in   der  die
ben\"otigten  Werte  aus der  Klasse  \code{Path}  ausgelesen werden  und  die
Berechnungen  mittels vorgegebenen  Fausformeln,  je  nach Controllertyp  (PI,
PID), durchgef\"urt werden.

\subsubsection*{PhaseRespsonseMethod}

In dieser Klasse wird die OmegaAchse  in Abh\"angigkeit vom Phasengang und des
ben\"otigten Winkelbereiches erstellt.

Ausserdem finden wir verschiedene calculate Merhoden.

Einerseits  ist da  calculate()  , in  dieser  wird die  UTF  Strecke aus  der
Strecke(path)  geholt  und  die  Omega-Achse  Methode  aufgeruffen. In  dieser
wird Sie  Abh\"angigkeit vom  Phasengang und des  ben\"otigten Winkelbereiches
erstellt.

Anschlissend werden die Werte f\"ur Hs und phiS berehnet.

Andererseits  sind  da die  Methoden,  calculateTnvTnk()  um  Tnk und  Tnv  zu
berechnen, calculateKrk um Krk zu berechnen, calculatecontrollerConf() um eine
umrechung  von Bodekonformen  Werten  zu Reglerkonformen  Werten  in der  calc
Klasse  auszul\"osen, calculatePhaseMargin()  bestimmt je  nach Reglertyp  den
Phasenrand  und zum  schluss calculateOverShoot(),  hier wird  je nach  vorher
berechnetem \"Uberschwingen, dem  Wert phiu einen der  4 vordefinierten static
final Werte zugewiesen.



\subsubsection*{Path}

Hier  giebt es  ebenfalls  eine Methode  \code{calculate()},  die mittels  der
Methode  \code{sani()} Methode  aus Utilities-Klasse  \code{Calc} die  Strecke
ausrechnet.

Die restlichen Klassen sind reine Getter- und Setter-Methoden.

Die  Alghorithmen zu  diesen  Methoden finden  Sie  im Anhang.  \todo{Verweise
Appendix}.
